-- Some general LUA functions.    
-- (c)2022 Tim Menzies <timm@ieee.org> BSD-2 license

local it={}

-- ## Linting
local b4={}; for k,v in pairs(_ENV) do b4[k]=v end
function it.rogues() --> nil; report rogue locals
  for k,v in pairs(_ENV) do
    if not b4[k] then print( it.fmt("#W ?%s %s",k,type(v)) ) end end end

-- ## Maths
function it.rnd(n, nPlaces) --> num. return `n` rounded to `nPlaces`
  local mult = 10^(nPlaces or 3)
  return math.floor(n * mult + 0.5) / mult end

-- ### Random number generator
-- The LUA doco says its random number generator is not stable across platforms.
-- Hence, we use our own (using Park-Miller).

local Seed=937162211
function it.srand(n)  --> nil; reset random number seed (defaults to 937162211) 
  Seed = n or 937162211 end

function it.rand(nlo,nhi) --> num; return float from `nlo`..`nhi` (default 0..1)
  nlo, nhi = nlo or 0, nhi or 1
  Seed = (16807 * Seed) % 2147483647
  return nlo + (nhi-nlo) * Seed / 2147483647 end

function it.rint(nlo,nhi)  --> int; returns integer from `nlo`..`nhi` (default 0..1)
  return math.floor(0.5 + it.rand(nlo,nhi)) end

-- ## Lists
function it.any(t) --> any; return any item from `t`, picked at random
  return t[it.rint(#t)] end

function it.many(t,n) --> t; return `n` items from `t`, picked at random
  local u={}; for i=1,n do it.push(u, it.any(t)) end; return u end 

function  it.per(t,p) --> num; return the `p`th(=.5) item of sorted list `t`
  p=math.floor(((p or .5)*#t)+.5); return t[math.max(1,math.min(#t,p))] end

 function it.pers(t,nps) --> t; return the `nps` items of sorted list `t`
   return it.map(nps,function(p) return it.per(t,p) end) end

function it.ent(t) --> num;  entropy
  local function calc(p) return p*math.log(p,2) end
  local n=0; for _,n1 in pairs(t) do n=n+n1 end
  local e=0; for _,n1 in pairs(t) do e=e - calc(n1/n) end 
  return e end

function it.kap(t, fun) --> t; map function `fun`(k,v) over list (skip nil results) 
  local u={}; for k,v in pairs(t)do u[k]=fun(k,v) end; return u end

function it.keys(t) --> t; sort+return `t`'s keys (ignore things with leading `_`)
  local function want(k,x) if tostring(k):sub(1,1) ~= "_" then return k end end
  local u={}; for k,v in pairs(t) do if want(k) then u[1+#u] = k end end
  return it.sort(u) end

function it.map(t, fun)  --> t; map function `fun`(v) over list (skip nil results) 
  local u={}; for i,v in pairs(t)do u[1+#u]=fun(v) end;return u end

function it.push(t, x) --> any; push `x` to end of list; return `x` 
  table.insert(t,x); return x end

function it.sd(t) --> num; sorted list standard deviation= (90-10)th percentile/2.58
  return (t[(.9*#t)//1] - t[(.1*#t)//1]) / 2.58 end

function it.slice(t, go, stop, inc) --> t; return `t` from `go`(=1) to `stop`(=#t), by `inc`(=1)
  local u={}; for j=(go or 1)//1,(stop or #t)//1,(inc or 1)//1 do u[1+#u]=t[j] end
  return u end

-- ### Sorting Lists
function it.gt(s) --> fun; return a function that sorts ascending on `s'.
  return function(a,b) return a[s] > b[s] end end

function it.lt(s) --> fun; return a function that sorts descending on `s`.
  return function(a,b) return a[s] < b[s] end end

function it.sort(t, fun) --> t; return `t`,  sorted by `fun` (default= `<`)
  table.sort(t,fun); return t end

-- ## Coercion
-- ### Strings to Things
function it.coerce(s) --> any; return int or float or bool or string from `s`
  local function fun(s1)
    if s1=="true"  then return true  end
    if s1=="false" then return false end
    return s1 end
  return math.tointeger(s) or tonumber(s) or fun(s:match"^%s*(.-)%s*$") end

function it.options(s,    t) --> t;  parse help string to extract a table of options
  t={}; s:gsub("\n [-][%S]+[%s]+[-][-]([%S]+)[^\n]+= ([%S]+)",
                 function(k,v) t[k]=it.coerce(v) end)
  t._help = s
  return t end

function it.csv(sFilename,fun) --> nil; call `fun` on rows (after coercing cell text)
  local src,s,t  = io.input(sFilename)
  while true do
    s = io.read()
    if   s
    then t={}; for s1 in s:gmatch("([^,]+)") do t[1+#t]=it.coerce(s1) end; fun(t)
    else return io.close(src) end end end

-- ### Things to Strings
function it.fmt(sControl,...) --> str; emulate printf
  return string.format(sControl,...) end

function it.oo(t)  --> nil; print `t`'s string (the one generated by `o`)
  print(it.o(t)) end

function it.o(t,  seen) --> str; table to string (recursive)
  if type(t) ~= "table" then return tostring(t) end
  local pre = t._is and it.fmt("%s%s",t._is,t._id or "") or ""
  seen=seen or {}
  if seen[t] then return it.fmt("<%s>",pre) end
  seen[t]=t
  local function filter(k) return it.fmt(":%s %s",k,it.o(t[k],seen)) end
  local u   = #t>0 and it.map(t,tostring) or it.map(it.keys(t),filter)
  return pre.."{".. table.concat(u," ").."}" end

-- ## Objects
local _id=0
local function id() _id=_id+1; return _id end

function it.obj(s,    t,new) --> t; create a klass and a constructor + print method
  local function new(k,...) 
     local i=setmetatable({_id=id()},k); t.new(i,...); return i end
  t={_is=s, __tostring = it.o}
  t.__index = t;return setmetatable(t,{__call=new}) end

-- Test suite support
function it.cli(t) --> t; alters contents of options in `t` from the  command-line
  for k,v in pairs(t) do
    local v=tostring(v)
    for n,x in ipairs(arg) do
      if x=="-"..(k:sub(1,1)) or x=="--"..k then
         v = v=="false" and "true" or v=="true" and "false" or arg[n+1] end end
    t[k] = it.coerce(v) end
  if t.help then os.exit(print(t._help)) end
  return t end

function it.run(funs,t) --> nfails; runs all `funs` (or `t.go`), resetting options & seed before each
  local fails,defaults = 0,{}
  for k,v in pairs(t) do defaults[k]=v end
  for _,k in pairs(it.keys(funs)) do
    if t.go == "ls" then print("\t",k) else
      if t.go == "all" or t.go==k then
        for k,v in pairs(defaults) do t[k]=v end
        it.srand(t.seed or 937162211)
        if funs[k]() == false 
        then print(it.fmt("# ❌ %s",k)); fails=fails+1 
        else print(it.fmt("# ✅ %s",k)) end end end end
   it.rogues()
   return fails end

-- -------------------------------
-- That's all folks.
return it
