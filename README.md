
# GLUA
(pronounced 'glue')

#	glua.lua	

Some general LUA functions.    	
(c)2022 Tim Menzies <timm@ieee.org> BSD-2 license	
## Linting	

| What | Notes |
|:---|:---|
| <b>l.rogues() &rArr;  nil</b> |  report rogue locals |


## Maths	

| What | Notes |
|:---|:---|
| <b>l.same(x, ...) &rArr;  x</b> |  return `x` unmodified |
| <b>l.sd(ns:`(num)+`, fun:`fun`) &rArr;  num</b> |  return standard deviation |


### Random number generator	
The LUA doco says its random number generator is not stable across platforms.	
Hence, we use our own (using Park-Miller).	

| What | Notes |
|:---|:---|
| <b>l.srand(n:`num`) &rArr;  nil</b> |  reset random number seed (defaults to 937162211)  |
| <b>l.rand(nlo:`num`, nhi:`num`) &rArr;  num</b> |  return float from `nlo`..`nhi` (default 0..1) |
| <b>l.rint(nlo:`num`, nhi:`num`) &rArr;  int</b> |  returns integer from `nlo`..`nhi` (default 0..1) |


## Lists	

| What | Notes |
|:---|:---|
| <b>l.any(t:`tab`) &rArr;  any</b> |  return any item from `t`, picked at random |
| <b>l.many(t:`tab`, n:`num`) &rArr;  t</b> |  return `n` items from `t`, picked at random |
| <b>l.per(t:`tab`, p) &rArr;  num</b> |  return the `p`th(=.5) item of sorted list `t` |
| <b>l.ent(t:`tab`) &rArr;  num</b> |   entropy |
| <b>l.kap(t:`tab`,  fun:`fun`) &rArr;  t</b> |  map function `fun`(k,v) over list (skip nil results)  |
| <b>l.keys(t:`tab`) &rArr;  t</b> |  sort+return `t`'s keys (ignore things with leading `_`) |
| <b>l.map(t:`tab`,  fun:`fun`) &rArr;  t</b> |  map function `fun`(v) over list (skip nil results)  |
| <b>l.push(t:`tab`,  x) &rArr;  any</b> |  push `x` to end of list; return `x`  |
| <b>l.slice(t:`tab`,  go,  stop:`str`,  inc) &rArr;  t</b> |  return `t` from `go`(=1) to `stop`(=#t), by `inc`(=1) |


### Sorting Lists	

| What | Notes |
|:---|:---|
| <b>l.gt(s:`str`) &rArr;  fun</b> |  return a function that sorts ascending on `s'. |
| <b>l.lt(s:`str`) &rArr;  fun</b> |  return a function that sorts descending on `s`. |
| <b>l.sort(t:`tab`,  fun:`fun`) &rArr;  t</b> |  return `t`,  sorted by `fun` (default= `<`) |


## Coercion	
### Strings to Things	

| What | Notes |
|:---|:---|
| <b>l.coerce(s:`str`) &rArr;  any</b> |  return int or float or bool or string from `s` |
| <b>l.options(s:`str`) &rArr;  t</b> |   parse help string to extract a table of options |
| <b>l.csv(sFilename:`str`, fun:`fun`) &rArr;  nil</b> |  call `fun` on rows (after coercing cell text) |


### Things to Strings	

| What | Notes |
|:---|:---|
| <b>l.fmt(sControl:`str`, ...) &rArr;  str</b> |  emulate printf |
| <b>l.oo(t:`tab`) &rArr;  nil</b> |  print `t`'s string (the one generated by `o`) |
| <b>l.o(t:`tab`,   seen:`str`?) &rArr;  str</b> |  table to string (recursive) |


## Objects	

| What | Notes |
|:---|:---|
| <b>l.obj(s:`str`) &rArr;  t</b> |  create a klass and a constructor + print method |


Test suite support	

| What | Notes |
|:---|:---|
| <b>l.cli(t:`tab`) &rArr;  t</b> |  alters contents of options in `t` from the  command-line |
| <b>l.run(t:`tab`, funs:`(fun)+`) &rArr;  nfails</b> |  runs all `funs` (or `t.go`), resetting options & seed before each |


-------------------------------	
That's all folks.	

#	../readme/readme.lua	

> Extract doco from LUA files to Markdown. Assumes a simple Hungarian notation.	
 	
For example, this file was generated via	
 	
      lua readme.lua readme.lua > README.md	
    	
## Why this code?	
I love documentation and I do not love most documentation 	
generators. 	
- Why are they so complex to use? 	
- Why can't they be really short and easy to change?	
- Why can't they just create tables for the functions,	
generated from in-line comments around the code? 	
- And if I use	
just a few simple naming conventions, why can't they add type	
hints to my favorite untyped languages (lua, lisp, etc)?	
  	
## Conventions	
 	
1. Lines with Markdown start with `-- ` (and  we will print those).	
2. We only show help on public function.	
3. Public functions are denoted with a  trailing "-->", followed by 	
   return type then some comment text. e.g.<br> 	
   `function fred(s) --> str; Returns `s`, written as a string`<br>   	
   Note the semi-colon. Do not skip it (its important).	
4. In public function arguments, lower case versions of class type 	
   (e.g. `data`) are instances of that type (e.g.  `data` are `DATA` 	
   so `datas` is a list of `DATA` instances).	
5  Built in types are num, str, tab, bool, fun	
6. User-defined types are ny word starting with two upper case 	
   leading letters is a class; e.g. DATA	
7. Public function arguments have the following type hints:	
   	
What        | Notes                                                                            	
:-----------|:--------------------------------------------	
2 blanks    | 2 blanks denote start of optional arguments 	
4 blanks    | 4 blanks denote start of local arguments   	
n           | prefix for numerics                       	
is          | prefix for booleans                   	
s           | prefix for strings                   	
suffix s    | list of thing (so `sfiles` is list of strings)	
suffix fun  | suffix for functions                                            	
  	
## Guessing types	

| What | Notes |
|:---|:---|
| <b>are.of(s:`str`) &rArr;  ?str</b> |   top level, guesses a variable's type |


Types are either singular (one thing) or plural (a set of	
things). The naming conventions for plurals is the same as	
singulars, we just add an `s`. E.g. `bools` is a table of	
booleans. and `ns` is a table of `n`umbers.	
Singulars are either `bools`, `fun` (function),	
`n` (number), `s` (string), or `t` (table).	

| What | Notes |
|:---|:---|
| <b>are.bool(s:`str`) &rArr;  ?"bool"</b> |  names starting with "is" are booleans |
| <b>are.fun(s:`str`) &rArr;  ?"fun"</b> |  names ending in "fun" are functions |
| <b>are.num(s:`str`) &rArr;  ?"n"</b> |  names start with "n" are numbers  |
| <b>are.str(s:`str`) &rArr;  ?"s"</b> |  names starting with "s" are strings |
| <b>are.tbl(s:`str`) &rArr;  ?"tab"</b> |  names ending the "s" are tables |


## Low-level utilities	

| What | Notes |
|:---|:---|
| <b>hint(s1:`str`, type) &rArr;  str</b> |  if we know a type, add to arg (else return arg) |
| <b>pretty(s:`str`) &rArr;  str</b> |  clean up the signature (no spaces, no local vars) |
| <b>optional(s:`str`) &rArr;  str</b> |  removes local vars, returns the rest as a string |
| <b>lines(sFilename:`str`,  fun:`fun`) &rArr;  nil</b> |  call `fun` on csv rows. |
| <b>dump() &rArr;  nil</b> |  if we have any tbl contents, print them then zap tbl |


## Main	

| What | Notes |
|:---|:---|
| <b>main(sFiles:`(str)+`) &rArr;  nil</b> |  for all lines on command line, print doco to standard output |


<img src='img/lib.png' width=150 align=right>